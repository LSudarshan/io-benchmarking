/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package file.writing;


import com.google.common.base.Charsets;
import com.google.common.io.Files;
import org.apache.commons.cli.*;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class App {

    private static final String RAW = "raw";
    private static final String BUFFERED = "buffered";
    private static final String MEMORYMAP = "memoryMap";
    private static Random random = new Random();

    public static void main(String[] args) throws IOException, ParseException {
        System.out.println("Max JVM memory: " + Runtime.getRuntime().maxMemory());

        CommandLineParser parser = new DefaultParser();
        CommandLine cmd = parser.parse(setupCommandlineOptions(), args);

        String path = cmd.getOptionValue("input");
        int numThreads = Integer.parseInt(cmd.getOptionValue("num_threads"));
        String outputLocation = cmd.getOptionValue("output");
        String operationType = cmd.getOptionValue("operation");

        List<String> lines = Files.readLines(new File(path), Charsets.UTF_8);

        if (operationType == RAW) {
            multiThread(() -> {
                try {
                    writeRaw(lines);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }, numThreads, RAW);
        } else if (operationType == BUFFERED) {

            multiThread(() -> {
                try {
                    writeBufered(lines, 8192, outputLocation);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }, numThreads, BUFFERED);
        } else if (operationType == MEMORYMAP) {

            multiThread(() -> {
                try {
                    writeMemoryMapped(lines, 1073741824);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }, numThreads, MEMORYMAP);
        }

    }

    private static Options setupCommandlineOptions() {
        Options options = new Options();
        Option threadsCountOption = new Option("n", "num_threads", true, "Number of threads");
        threadsCountOption.setRequired(true);
        options.addOption(threadsCountOption);
        Option inputFileOption = new Option("i", "input", true, "Input file");
        inputFileOption.setRequired(true);
        options.addOption(inputFileOption);
        Option outputFileOption = new Option("o", "output", true, "Output file");
        outputFileOption.setRequired(true);
        options.addOption(outputFileOption);
        Option writeOption = new Option("t", "operation", true, "Type of IO write operation - raw | buffered | memoryMap");
        writeOption.setRequired(true);
        options.addOption(writeOption);
        return options;
    }

    private static void multiThread(Runnable r, int numThreads, String operationType) {
        List<Thread> threads = new ArrayList<>();
        System.out.println("Starting threads: " + numThreads + " for operation: " + operationType);
        long start = System.currentTimeMillis();
        for (int i =0; i< numThreads; i++){
            Thread thread = new Thread(r);
            threads.add(thread);
            thread.start();
        }
        threads.forEach(thread -> {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        long end = System.currentTimeMillis();
        float duration = (end - start) / 1000f;
        System.out.println("Overall time for OperationType: " + operationType + " is : " + duration + " seconds");
    }

    private static void writeRaw(List<String> records) throws IOException {
        File file = File.createTempFile("foo", ".txt", new File("/tmp"));
        FileWriter writer = new FileWriter(file);
        System.out.print("Writing raw... ");
        write(records, writer);
    }

    private static void writeMemoryMapped(List<String> records, int size) throws IOException {
        FileChannel rwChannel = new RandomAccessFile("/tmp/memoryMapped" + random.nextInt() + ".txt", "rw").getChannel();
        ByteBuffer wrBuf = rwChannel.map(FileChannel.MapMode.READ_WRITE, 0, size);
        System.out.print("Writing memoryMapped... ");
        long start = System.currentTimeMillis();
        for (int i = 0; i < records.size(); i++)
        {
            wrBuf.put(records.get(i).getBytes());
        }
        rwChannel.close();
        long end = System.currentTimeMillis();
        System.out.println((end - start) / 1000f + " seconds");
    }

    private static void writeBufered(List<String> records, int buffer, String outputLocation) throws IOException {
        File file = File.createTempFile("bufferedFoo",  ".txt", new File(outputLocation));
        FileWriter writer = new FileWriter(file);
        BufferedWriter bufferedWriter = new BufferedWriter(writer, buffer);

        System.out.print("Writing buffered (buffer size: " + buffer + ")... ");
        write(records, bufferedWriter);
    }


    private static void write(List<String> records, Writer writer) throws IOException {
        long start = System.currentTimeMillis();
        for (String record: records) {
            writer.write(record);
        }
        // writer.flush(); // close() should take care of this
        writer.close();
        long end = System.currentTimeMillis();
        System.out.println((end - start) / 1000f + " seconds");
    }

}
